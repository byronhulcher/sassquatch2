body { // TODO: reight place for this?
	position: relative;
}


// TODO: need to doc all of this

/*doc
---
title: Views
name: views
category: Core
---
*/


/*doc
---
title: View hero
name: hero
parent: views
---

```html_example
<header class="stripe--hero" style="background-image: url(http://photos4.meetupstatic.com/photos/event/9/7/7/2/600_432758770.jpeg);">
	<div class="bounds stripe--hero-content inverted">
		<h1 class="text--display">Hero header heading</h1>
	</div>
</header>
```
*/
.stripe--hero-content {
	@extend %valignChildren--bottom; // maybe try to align without this?
	min-height: $block-6;
	position: relative;

	@include atMediaDown(medium) {
		min-height: $block-5;
	}
}


@mixin modal-dialog{
	@include transform( translate3d(0, 0, 0) );
	@include transition(transform .2s ease);
	left: 50%;
	margin-left: -($modal-width/2);
	margin-top: 10vh; // Can we do this kind of thing on native?
	min-height: $modal-width;
	position: absolute;
	width: $modal-width;

	&.off{
	  @include transform( translateY(100vh) );
	}
  }

@mixin modal-full{
	@include transform( translate3d(0, 0, 0) );
	@include transition(transform .3s);
	left: 0;
	margin: 0;
	min-height: 100vh;
	position: absolute;
	top: 0;
	width: 100%;

	&.off{
		@include transform( translateY(100vh) );
	}
}


.view{
	// adjust padding when view has transparent head
	&.has-hero{
		padding-top: 0;
	}

  // SPLIT VIEW
  // at narrow widths, show split view as separate screens based on js
  &.view--split, &.view--detail{
	  display: none;
	  &.focus{
		  display: block;
	  }
  }
  }
}

// MODAL VIEW FULL
// full screen at all screen widths
.view--modal-full {
	@include modal-full;
	z-index: map-get($zindex-map, "modal");
}

// MODAL VIEW SNAP
// full at narrow widths, dialog at wide widths
.view--modal-snap {
	@include modal-dialog;
	@include atMediaDown(small){
		@include modal-full;
	}
	z-index: map-get($zindex-map, "modal");
}



// HEAD
// the navigationbar/actionbar at the top of the view
// contains an escape action, a title, and screen actions

.viewHead{
	// TODO: change bounds variants to view-head-[thing]
	// which search mode
	.bounds--standard{ display: block; }
	.bounds--search{ display: none; }
	&.viewHead--search{
		.bounds--standard{ display: none; }
		.bounds--search{ display: block; }
	}

	.bounds{
		padding: 0 $space;
	}

	.bounds, .ffbox{
		height: 100%; // for vertical-alignment
	}

	.viewHead-back {
	  width: 24px;
	}

	.viewHead-actions {
	  // ------------------------
	  // Need to kill padding given
	  // by .ffbox children in .view-head
	  // because each icon has padding attached to it
	  padding: 0 !important;
	  white-space: nowrap;
	a {
	  box-sizing: border-box;
	  display: inline-block;
	  padding: 0 $space-half;

	  // Is this right?
	  &:last-child {
		padding-right: 0;
	  }
	  }
	}

	// TRANSPARENT HEAD WHEN SCREEN HAS A HERO STRIPE TO SHOW
	&.has-hero{
		background: transparent;
		border-bottom: none;
		color: $C_textPrimaryInverted;
		h1{
			opacity: 0;
		}
	}
	&.has-hero.has-hero-photo{
		@include background(linear-gradient(transparentize(#000000, .4), transparentize(#000000, 1) ));
	}
}


// VIEWHEAD SEARCH
// THIS IS KIND OF GROSS
.viewHead--search{
	display: none;
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	background: $C_accent;
}
.view--searchMode{
	.viewHead--search{
		display: block;
	}
	.viewBody{
		display: none;
	}
}


// SHADE
// dims main (and split) views when modal appears
.shade{
	height: 100%;
	left: 0;
	position: absolute;
	top: 0;
	width: 100%;
	z-index: map-get($zindex-map, "shade");
	@include transition(all .15s);
	background: $C_modalShade;
	opacity: 1;
	.x{
		@include transition(all .15s .15s);
		display: block;
		height: 100vh;
		left: 0;
		line-height: 100vh;
		position: fixed;
		text-align: center;
		top: 0;
		vertical-align: middle;
		width: 100%;
	}
	&.off{
		opacity: 0;
		.x{
			opacity: 0;
		}
	}
}

